<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GameService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">projekt2</a> &gt; <a href="index.source.html" class="el_package">service</a> &gt; <span class="el_source">GameService.kt</span></div><h1>GameService.kt</h1><pre class="source lang-java linenums">package service

import entity.*
import java.io.File

<span class="fc" id="L6">class GameService(private val rootService: RootService): AbstractRefreshingService() {</span>

<span class="fc" id="L8">    var consecutiveNoAction = 0</span>
<span class="pc" id="L9">    var currentPlayerIndex = 0</span>

    fun startNewGame(
        players: List&lt;Pair&lt;String,PlayerType&gt;&gt;,
        randomizedTurns: Boolean,
        simulationSpeed: Int) {
<span class="fc bfc" id="L15" title="All 6 branches covered.">        require(players.size in 2..4) { &quot;invalid players' number&quot; }</span>

        // create players
<span class="fc" id="L18">        val playerList = mutableListOf&lt;Player&gt;()</span>
<span class="fc bfc" id="L19" title="All 2 branches covered.">        for(player in players){</span>
<span class="fc" id="L20">            playerList.add(Player(player.first,player.second))</span>
        }
        // check if order should be randomized
<span class="fc bfc" id="L23" title="All 2 branches covered.">        if (randomizedTurns) {</span>
<span class="fc" id="L24">            playerList.shuffle()</span>
        }

<span class="fc" id="L27">        val levelOneStack = createCardStack(1)</span>
<span class="fc" id="L28">        levelOneStack.shuffle()</span>
<span class="fc" id="L29">        val levelOneOpen = levelOneStack.slice(0..3).toMutableList()</span>

<span class="fc" id="L31">        val levelTwoStack = createCardStack(2)</span>
<span class="fc" id="L32">        levelTwoStack.shuffle()</span>
<span class="fc" id="L33">        val levelTwoOpen = levelTwoStack.slice(0..3).toMutableList()</span>

<span class="fc" id="L35">        val levelThreeStack = createCardStack(3)</span>
<span class="fc" id="L36">        levelThreeStack.shuffle()</span>
<span class="fc" id="L37">        val levelThreeOpen = levelThreeStack.slice(0..3).toMutableList()</span>

<span class="fc bfc" id="L39" title="All 2 branches covered.">        for(i in 0..3){</span>
<span class="fc" id="L40">            levelOneStack.removeAt(i)</span>
<span class="fc" id="L41">            levelTwoStack.removeAt(i)</span>
<span class="fc" id="L42">            levelThreeStack.removeAt(i)</span>
        }

        // create Board
<span class="fc" id="L46">        val board = Board(</span>
<span class="fc" id="L47">            createNobleTiles(players.size),</span>
<span class="fc" id="L48">            levelOneStack,</span>
<span class="fc" id="L49">            levelOneOpen,</span>
<span class="fc" id="L50">            levelTwoStack,</span>
<span class="fc" id="L51">            levelTwoOpen,</span>
<span class="fc" id="L52">            levelThreeStack,</span>
<span class="fc" id="L53">            levelThreeOpen</span>
        )
        //create GameState
<span class="fc" id="L56">        val gameState = GameState(</span>
<span class="fc" id="L57">            playerList[0],</span>
<span class="fc" id="L58">            playerList,</span>
<span class="fc" id="L59">            board</span>
        )
        //create Splendor(current game)
<span class="fc" id="L62">        val splendor = Splendor(</span>
<span class="fc" id="L63">            simulationSpeed,</span>
<span class="fc" id="L64">            gameState,</span>
<span class="fc" id="L65">            mutableListOf()</span>
        )

<span class="fc" id="L68">        consecutiveNoAction = 0</span>
<span class="fc" id="L69">        currentPlayerIndex = 0</span>

<span class="fc" id="L71">        rootService.currentGame = splendor</span>

//        onAllRefreshable { refreshAfterStartGame() }
<span class="fc" id="L74">    }</span>

    /**
     * create a new game state, link it to the chain and set the pointer to this game state
     * if nobody can make a move or the current Player hat 15 point -&gt; endGame()
     */
    fun nextPlayer(){
<span class="fc" id="L81">        val game = rootService.currentGame</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        checkNotNull(game)</span>
<span class="fc" id="L83">        val currentGameState = game.currentGameState</span>
<span class="fc" id="L84">        val board = game.currentGameState.board</span>
<span class="fc" id="L85">        val currentPlayer = currentGameState.currentPlayer</span>

<span class="fc" id="L87">        currentPlayerIndex = (currentPlayerIndex + 1) % currentGameState.playerList.size</span>
<span class="fc" id="L88">        val totalGemsOnBoard = board.gems.values.sum() - board.gems.getValue(GemType.YELLOW)</span>
<span class="fc" id="L89">        val affordableCards = acquirableCards().size</span>
<span class="fc" id="L90">        val reservedCards = currentGameState.playerList[currentPlayerIndex].reservedCards.size</span>

        //check if there are any valid move, if nobody can make a move -&gt; endGame()
<span class="pc bpc" id="L93" title="2 of 6 branches missed.">        if((totalGemsOnBoard == 0) &amp;&amp; (affordableCards == 0) &amp;&amp; (reservedCards == 3)){</span>
//            onAllRefreshables { refreshIfNoValidAction() }
<span class="fc" id="L95">            consecutiveNoAction++</span>
        }

        // if one player reach 15 or above -&gt; end game
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if(currentGameState.playerList[currentPlayerIndex].score &gt;= 15){</span>
<span class="fc" id="L100">            currentGameState.playerList = currentGameState.playerList.sortedByDescending { player -&gt; player.score }</span>
<span class="fc" id="L101">            println(currentGameState.playerList.toString())</span>
//            onAllRefreshables { refreshAfterEndGame(false) }
<span class="fc" id="L103">            return</span>
        }
        // if no player can make any move, end game with tie result
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if(consecutiveNoAction == currentGameState.playerList.size){</span>
<span class="nc" id="L107">            currentGameState.playerList = currentGameState.playerList.sortedByDescending { player -&gt; player.score }</span>
//            onAllRefreshables { refreshAfterEndGame(true) }
<span class="nc" id="L109">            return</span>
        }

<span class="fc" id="L112">        val newPlayerList = mutableListOf&lt;Player&gt;()</span>
<span class="fc" id="L113">        val newBoard = Board(</span>
<span class="fc" id="L114">            board.nobleTiles.toMutableList(),</span>
<span class="fc" id="L115">            board.levelOneCards.toMutableList(),</span>
<span class="fc" id="L116">            board.levelOneOpen.toMutableList(),</span>
<span class="fc" id="L117">            board.levelTwoCards.toMutableList(),</span>
<span class="fc" id="L118">            board.levelTwoCards.toMutableList(),</span>
<span class="fc" id="L119">            board.levelThreeCards.toMutableList(),</span>
<span class="fc" id="L120">            board.levelThreeOpen.toMutableList(),</span>
<span class="fc" id="L121">            board.gems.toMutableMap()</span>
        )

        // create a new players list with the properties of the current list
<span class="fc" id="L125">        currentGameState.playerList.forEach { player -&gt;</span>
<span class="fc" id="L126">            newPlayerList.add(</span>
<span class="fc" id="L127">                Player(</span>
<span class="fc" id="L128">                    player.name,</span>
<span class="fc" id="L129">                    player.playerType,</span>
<span class="fc" id="L130">                    player.gems,</span>
<span class="fc" id="L131">                    player.bonus</span>
                )
            )
<span class="fc" id="L134">        }</span>

        //create new GameState
<span class="fc" id="L137">        val newGameState = GameState(</span>
<span class="fc" id="L138">            newPlayerList[currentPlayerIndex],</span>
<span class="fc" id="L139">            newPlayerList,</span>
<span class="fc" id="L140">            newBoard</span>
        )

        //bind new gameState to chain and set pointer to the newGameState
<span class="fc" id="L144">        newGameState.previous = currentGameState</span>
<span class="fc" id="L145">        game.currentGameState = newGameState</span>

//        onAllRefreshables { refreshAfterNextPlayer }
<span class="fc" id="L148">    }</span>

//    /**
//     * End game
//     *
//     * @return a list sort by players' score
//     */
//    fun endGame(){
//        val game = rootService.currentGame
//        checkNotNull(game)
//        val currentGameState = game.currentGameState
//
//        currentGameState.playerList = currentGameState.playerList.sortedByDescending { player -&gt; player.score }
//    }

    /**
     * deal a new card to the same place, where a card was removed
     *
     * @param level level of the card
     * @param index  index of the removed card
     */
    fun refill(level: Int,index: Int){
<span class="nc" id="L170">        val game = rootService.currentGame</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        checkNotNull(game)</span>
<span class="nc" id="L172">        val board = game.currentGameState.board</span>

<span class="nc bnc" id="L174" title="All 4 branches missed.">        when(level){</span>
            1 -&gt; {
<span class="nc" id="L176">                board.levelOneOpen.add(index,board.levelOneCards[0])</span>
<span class="nc" id="L177">                board.levelOneCards.removeAt(0)</span>
            }
            2 -&gt; {
<span class="nc" id="L180">                board.levelTwoOpen.add(index,board.levelTwoCards[0])</span>
<span class="nc" id="L181">                board.levelTwoCards.removeAt(0)</span>
            }
            3 -&gt; {
<span class="nc" id="L184">                board.levelThreeOpen.add(index,board.levelThreeCards[0])</span>
<span class="nc" id="L185">                board.levelThreeCards.removeAt(0)</span>
            }
        }
<span class="nc" id="L188">    }</span>


    /**
     * Check which noble tiles can visit the current player
     * automatic add prestige point to player score if there is only on affordable card
     * @return a mutable list of indexes of the affordable noble tiles on board
     */
    fun checkNobleTiles(): MutableList&lt;Int&gt;{

<span class="nc" id="L198">        val game = rootService.currentGame</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        checkNotNull(game)</span>
<span class="nc" id="L200">        val board = game.currentGameState.board</span>
<span class="nc" id="L201">        val player = game.currentGameState.currentPlayer</span>
<span class="nc" id="L202">        val affordableNobleTile = mutableListOf&lt;Int&gt;()</span>

<span class="nc" id="L204">        board.nobleTiles.forEach { nobleTile -&gt;</span>
<span class="nc" id="L205">            var affordable = true</span>
<span class="nc" id="L206">            nobleTile.condition.forEach { (type, num) -&gt;</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">                affordable = affordable &amp;&amp; (player.bonus.getValue(type) &gt;= num )</span>
<span class="nc" id="L208">            }</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if(affordable){ affordableNobleTile.add(board.nobleTiles.indexOf(nobleTile)) }</span>
<span class="nc" id="L210">        }</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if(affordableNobleTile.size == 1){</span>
<span class="nc" id="L213">            player.score += board.nobleTiles[affordableNobleTile[0]].prestigePoints</span>
        }

<span class="nc" id="L216">        return affordableNobleTile</span>
    }

    fun checkGems(): Boolean{

<span class="nc" id="L221">        val game = rootService.currentGame</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        checkNotNull(game)</span>
<span class="nc" id="L223">        val player = game.currentGameState.currentPlayer</span>
<span class="nc" id="L224">        var totalGems = 0</span>

<span class="nc" id="L226">        player.gems.forEach{ (_,v) -&gt;</span>
<span class="nc" id="L227">            totalGems += v</span>
<span class="nc" id="L228">        }</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">        return totalGems &gt;= 10</span>
    }


    /*-----------------------------HELP FUNCTION-----------------------------*/

    private fun createNobleTiles(playerCount: Int): MutableList&lt;NobleTile&gt; {

<span class="fc" id="L238">        val nobleTileFile = &quot;src/main/resources/splendor-adligenkarten.csv&quot;</span>
<span class="fc" id="L239">        val cardProps: MutableList&lt;String&gt; = File(nobleTileFile).readLines().toMutableList()</span>
<span class="fc" id="L240">        cardProps.removeAt(0)</span>
<span class="fc" id="L241">        val nobleCards = mutableListOf&lt;NobleTile&gt;()</span>

<span class="fc" id="L243">        cardProps.forEach { cardProp -&gt;</span>
<span class="fc" id="L244">            val cardConfig = cardProp.split(&quot;, &quot;)</span>
<span class="fc" id="L245">            val tempMap = mapOf(</span>
<span class="fc" id="L246">                GemType.WHITE to cardConfig[1].trim().toInt(),</span>
<span class="fc" id="L247">                GemType.BLUE to cardConfig[2].trim().toInt(),</span>
<span class="fc" id="L248">                GemType.GREEN to cardConfig[3].trim().toInt(),</span>
<span class="fc" id="L249">                GemType.RED to cardConfig[4].trim().toInt(),</span>
<span class="fc" id="L250">                GemType.BLACK to cardConfig[5].trim().toInt()</span>
            )
<span class="fc" id="L252">            nobleCards.add(</span>
<span class="fc" id="L253">                NobleTile(</span>
<span class="fc" id="L254">                    cardConfig[0].trim().toInt(),</span>
<span class="fc" id="L255">                    tempMap,</span>
<span class="fc" id="L256">                    cardConfig[6].trim().toInt()</span>
                )
            )
<span class="fc" id="L259">        }</span>
<span class="fc" id="L260">        nobleCards.shuffle()</span>
<span class="fc" id="L261">        return  nobleCards.slice(0..playerCount).toMutableList()</span>
    }


    private fun createCardStack(level: Int): MutableList&lt;DevCard&gt;{

<span class="fc" id="L267">        val cardConfigFile = &quot;src/main/resources/splendor-entwicklungskarten.csv&quot;</span>
<span class="fc" id="L268">        val cardConfigs: MutableList&lt;String&gt; = File(cardConfigFile.trim()).readLines().toMutableList()</span>
<span class="fc" id="L269">        cardConfigs.removeAt(0)</span>
<span class="fc" id="L270">        val cardList = mutableListOf&lt;DevCard&gt;()</span>

<span class="fc bfc" id="L272" title="All 3 branches covered.">        when (level) {</span>
            1 -&gt; {
<span class="fc bfc" id="L274" title="All 2 branches covered.">                for(i in 0..39){</span>
<span class="fc" id="L275">                    val cardConfig = cardConfigs[i].split(&quot;, &quot;)</span>
<span class="fc" id="L276">                    cardList.add(createCard(cardConfig))</span>
                }
            }
            2 -&gt; {
<span class="fc bfc" id="L280" title="All 2 branches covered.">                for(i in 40..69){</span>
<span class="fc" id="L281">                    val cardConfig = cardConfigs[i].split(&quot;, &quot;)</span>
<span class="fc" id="L282">                    cardList.add(createCard(cardConfig))</span>
                }
            }
            else -&gt; {
<span class="fc bfc" id="L286" title="All 2 branches covered.">                for(i in 70..89){</span>
<span class="fc" id="L287">                    val cardConfig = cardConfigs[i].split(&quot;, &quot;)</span>
<span class="fc" id="L288">                    cardList.add(createCard(cardConfig))</span>
                }
            }
        }
<span class="fc" id="L292">        return cardList</span>

    }


    // create and ass a development card to board with input of list of card's properties
    fun createCard(cardProp: List&lt;String&gt;): DevCard {

<span class="fc" id="L300">        val tempMap = mapOf(</span>
<span class="fc" id="L301">            GemType.WHITE to cardProp[1].trim().toInt(),</span>
<span class="fc" id="L302">            GemType.BLUE to cardProp[2].trim().toInt(),</span>
<span class="fc" id="L303">            GemType.GREEN to cardProp[3].trim().toInt(),</span>
<span class="fc" id="L304">            GemType.RED to cardProp[4].trim().toInt(),</span>
<span class="fc" id="L305">            GemType.BLACK to cardProp[5].trim().toInt()</span>
        )
<span class="fc bfc" id="L307" title="All 6 branches covered.">        val color = when (cardProp[8].trim()) {</span>
<span class="fc" id="L308">            &quot;diamant&quot; -&gt; GemType.WHITE</span>
<span class="fc" id="L309">            &quot;saphir&quot; -&gt; GemType.BLUE</span>
<span class="fc" id="L310">            &quot;smaragd&quot; -&gt; GemType.GREEN</span>
<span class="fc" id="L311">            &quot;rubin&quot; -&gt; GemType.RED</span>
<span class="fc" id="L312">            &quot;onyx&quot; -&gt; GemType.BLACK</span>
            else -&gt; {
<span class="fc" id="L314">                throw java.lang.IllegalArgumentException(</span>
<span class="fc" id="L315">                    &quot;invalid gem type&quot;</span>
                )
            }
        }
        //create card
<span class="fc" id="L320">        return DevCard(</span>
<span class="fc" id="L321">            cardProp[0].trim().toInt(),</span>
<span class="fc" id="L322">            tempMap,</span>
<span class="fc" id="L323">            cardProp[6].trim().toInt(),</span>
<span class="fc" id="L324">            cardProp[7].trim().toInt(),</span>
<span class="fc" id="L325">            color</span>
        )

    }

    /**
     * check if the card is for the current player affordable
     *
     * @param card the card which the player chose
     * @param payment map of gems from player
     * @return true if player can this card afford, else return false
     * */
    fun isCardAcquirable(card: DevCard, payment: Map&lt;GemType,Int&gt;): Boolean {

<span class="fc" id="L339">        val tempGemMap = card.price.toMutableMap()</span>

<span class="fc" id="L341">        card.price.forEach { (gemType) -&gt;</span>
<span class="fc" id="L342">            tempGemMap[gemType] = tempGemMap.getValue(gemType) - payment.getValue(gemType)</span>
<span class="fc" id="L343">        }</span>

<span class="pc bpc" id="L345" title="2 of 4 branches missed.">        val gemsNeeded = tempGemMap.filterValues { it &gt;= 0 }.values.sum()</span>
<span class="fc bfc" id="L346" title="All 4 branches covered.">        return (gemsNeeded == 0) || (gemsNeeded &lt;= payment.getValue(GemType.YELLOW))</span>
    }

    /**
     * check if there are any open card, which player can afford
     *
     * @return a list of Pair( level, cardIndex ) of acquirable card
     */
    private fun acquirableCards(): MutableList&lt;Pair&lt;Int,Int&gt;&gt;{

<span class="fc" id="L356">        val game = rootService.currentGame</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        checkNotNull(game)</span>
<span class="fc" id="L358">        val board = game.currentGameState.board</span>
<span class="fc" id="L359">        val playerBonus = game.currentGameState.currentPlayer.bonus</span>
<span class="fc" id="L360">        val playerGems = game.currentGameState.currentPlayer.gems</span>
<span class="fc" id="L361">        val listOfAcquirableCards = mutableListOf&lt;Pair&lt;Int,Int&gt;&gt;()</span>
<span class="fc" id="L362">        val totalOwn : Map&lt;GemType,Int&gt; = mapOf(</span>
<span class="fc" id="L363">            GemType.RED    to (playerBonus.getValue(GemType.RED)   + playerGems.getValue(GemType.RED)),</span>
<span class="fc" id="L364">            GemType.GREEN  to (playerBonus.getValue(GemType.GREEN) + playerGems.getValue(GemType.GREEN)),</span>
<span class="fc" id="L365">            GemType.WHITE  to (playerBonus.getValue(GemType.WHITE) + playerGems.getValue(GemType.WHITE)),</span>
<span class="fc" id="L366">            GemType.BLACK  to (playerBonus.getValue(GemType.BLACK) + playerGems.getValue(GemType.BLACK)),</span>
<span class="fc" id="L367">            GemType.BLUE   to (playerBonus.getValue(GemType.BLUE)  + playerGems.getValue(GemType.BLUE)),</span>
<span class="fc" id="L368">            GemType.YELLOW to   playerGems.getValue(GemType.YELLOW)</span>
        )

<span class="fc bfc" id="L371" title="All 2 branches covered.">        for(i in 0..3){</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            if(isCardAcquirable(board.levelOneOpen[i], totalOwn)){</span>
<span class="nc" id="L373">                listOfAcquirableCards.add(Pair(1,i))</span>
            }
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">            if(isCardAcquirable(board.levelTwoOpen[i], totalOwn)){</span>
<span class="nc" id="L376">                listOfAcquirableCards.add(Pair(2,i))</span>
            }
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if(isCardAcquirable(board.levelThreeOpen[i], totalOwn)){</span>
<span class="nc" id="L379">                listOfAcquirableCards.add(Pair(3,i))</span>
            }
        }

<span class="fc" id="L383">        return listOfAcquirableCards</span>
    }

//    /**
//     * Check if the current player can perform any valid move in this turn
//     *
//     * @return true if there are at least one valid action. False if there is no valid action.
//     *
//     */
//    fun checkValidAction(): Boolean{
//
//        val game = rootService.currentGame
//        checkNotNull(game)
//        val board = game.currentGameState.board
//        val currentPlayer = game.currentGameState.currentPlayer
//        var totalGemsOnBoard = board.gems.values.sum() - board.gems.getValue(GemType.YELLOW)
//        val affordableCards = acquirableCards().size
//        val reservedCards = currentPlayer.gems.size
//
//        return (totalGemsOnBoard != 0) || (affordableCards != 0) || (reservedCards &lt; 3)
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>