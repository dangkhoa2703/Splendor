<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GameService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">projekt2</a> &gt; <a href="index.source.html" class="el_package">service</a> &gt; <span class="el_source">GameService.kt</span></div><h1>GameService.kt</h1><pre class="source lang-java linenums">package service

import entity.*
import java.io.File

/**
 *  class for basic game functionalities
 * */
<span class="fc" id="L9">class GameService(private val rootService: RootService): AbstractRefreshingService() {</span>

<span class="fc" id="L11">    var consecutiveNoAction = 0</span>
<span class="fc" id="L12">    var currentPlayerIndex = 0</span>

    /** initializes a new game and connects it to the rootService */
    fun startNewGame(
        players: List&lt;Pair&lt;String,PlayerType&gt;&gt;,
        randomizedTurns: Boolean,
        simulationSpeed: Int) {
<span class="fc bfc" id="L19" title="All 6 branches covered.">        require(players.size in 2..4) { &quot;invalid players' number&quot; }</span>

        // create players
<span class="fc" id="L22">        val playerList = mutableListOf&lt;Player&gt;()</span>
<span class="fc bfc" id="L23" title="All 2 branches covered.">        for(player in players) {</span>
<span class="fc" id="L24">            playerList.add(Player(player.first,player.second)) }</span>
        // check if order should be randomized
<span class="fc bfc" id="L26" title="All 2 branches covered.">        if (randomizedTurns) {</span>
<span class="fc" id="L27">            playerList.shuffle() }</span>

<span class="fc" id="L29">        val levelOneStack = createCardStack(1)</span>
<span class="fc" id="L30">        levelOneStack.shuffle()</span>
<span class="fc" id="L31">        val levelOneOpen = levelOneStack.slice(0..3).toMutableList()</span>

<span class="fc" id="L33">        val levelTwoStack = createCardStack(2)</span>
<span class="fc" id="L34">        levelTwoStack.shuffle()</span>
<span class="fc" id="L35">        val levelTwoOpen = levelTwoStack.slice(0..3).toMutableList()</span>

<span class="fc" id="L37">        val levelThreeStack = createCardStack(3)</span>
<span class="fc" id="L38">        levelThreeStack.shuffle()</span>
<span class="fc" id="L39">        val levelThreeOpen = levelThreeStack.slice(0..3).toMutableList()</span>

<span class="fc bfc" id="L41" title="All 2 branches covered.">        for(i in 0..3) {</span>
<span class="fc" id="L42">            levelOneStack.removeAt(i)</span>
<span class="fc" id="L43">            levelTwoStack.removeAt(i)</span>
<span class="fc" id="L44">            levelThreeStack.removeAt(i)</span>
        }

        // create Board
<span class="fc" id="L48">        val board = Board(</span>
<span class="fc" id="L49">            createNobleTiles(players.size),</span>
<span class="fc" id="L50">            levelOneStack,</span>
<span class="fc" id="L51">            levelOneOpen,</span>
<span class="fc" id="L52">            levelTwoStack,</span>
<span class="fc" id="L53">            levelTwoOpen,</span>
<span class="fc" id="L54">            levelThreeStack,</span>
<span class="fc" id="L55">            levelThreeOpen)</span>

        //create GameState
<span class="fc" id="L58">        val gameState = GameState(</span>
<span class="fc" id="L59">            playerList[0],</span>
<span class="fc" id="L60">            playerList,</span>
<span class="fc" id="L61">            board)</span>

        //create Splendor(current game)
<span class="fc" id="L64">        val splendor = Splendor(</span>
<span class="fc" id="L65">            simulationSpeed,</span>
<span class="fc" id="L66">            gameState,</span>
<span class="fc" id="L67">            mutableListOf())</span>

<span class="fc" id="L69">        consecutiveNoAction = 0</span>
<span class="fc" id="L70">        currentPlayerIndex = 0</span>

<span class="fc" id="L72">        rootService.currentGame = splendor</span>
<span class="pc" id="L73">        onAllRefreshables { refreshAfterStartNewGame() }</span>
<span class="fc" id="L74">    }</span>

    /**
     * create a new game state, link it to the chain and set the pointer to this game state
     * if nobody can make a move or the current Player hat 15 point -&gt; endGame()
     */
    fun nextPlayer(){
<span class="fc" id="L81">        val game = rootService.currentGame</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">        checkNotNull(game)</span>
<span class="fc" id="L83">        val currentGameState = game.currentGameState</span>
<span class="fc" id="L84">        val board = game.currentGameState.board</span>

<span class="fc" id="L86">        currentPlayerIndex = (currentPlayerIndex + 1) % currentGameState.playerList.size</span>

        // if current player reach 15 or above -&gt; end game
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if(currentGameState.currentPlayer.score &gt;= 15){</span>
<span class="fc" id="L90">            currentGameState.playerList = currentGameState.playerList.sortedByDescending { player -&gt; player.score }</span>
<span class="fc" id="L91">            println(currentGameState.playerList.toString())</span>
//            onAllRefreshables { refreshAfterEndGame(false) }
<span class="fc" id="L93">            return</span>
        }

        //create new state
<span class="fc" id="L97">        val newPlayerList = mutableListOf&lt;Player&gt;()</span>
<span class="fc" id="L98">        println(board.gems.toString())</span>
<span class="fc" id="L99">        val tempBoard = Board(</span>
<span class="fc" id="L100">            board.nobleTiles.toMutableList(),</span>
<span class="fc" id="L101">            board.levelOneCards.toMutableList(),</span>
<span class="fc" id="L102">            board.levelOneOpen.toMutableList(),</span>
<span class="fc" id="L103">            board.levelTwoCards.toMutableList(),</span>
<span class="fc" id="L104">            board.levelTwoCards.toMutableList(),</span>
<span class="fc" id="L105">            board.levelThreeCards.toMutableList(),</span>
<span class="fc" id="L106">            board.levelThreeOpen.toMutableList(),</span>
<span class="fc" id="L107">            board.gems.toMutableMap()</span>
        )

        // create a new players list with the properties of the current list
<span class="fc" id="L111">        currentGameState.playerList.forEach { player -&gt;</span>
<span class="fc" id="L112">            newPlayerList.add(</span>
<span class="fc" id="L113">                Player(</span>
<span class="fc" id="L114">                    player.name,</span>
<span class="fc" id="L115">                    player.playerType,</span>
<span class="fc" id="L116">                    player.gems,</span>
<span class="fc" id="L117">                    player.bonus,</span>
<span class="fc" id="L118">                    player.reservedCards,</span>
<span class="fc" id="L119">                    player.nobleTiles,</span>
<span class="fc" id="L120">                    player.score,</span>
<span class="fc" id="L121">                    player.devCards</span>
                )
            )
<span class="fc" id="L124">        }</span>
<span class="fc" id="L125">        val newGameState = GameState(</span>
<span class="fc" id="L126">            newPlayerList[currentPlayerIndex],</span>
<span class="fc" id="L127">            newPlayerList,</span>
<span class="fc" id="L128">            tempBoard)</span>

        //bind new gameState to chain and set pointer to the newGameState
<span class="fc" id="L131">        newGameState.previous = currentGameState</span>
<span class="fc" id="L132">        game.currentGameState = newGameState</span>
<span class="fc" id="L133">        val newCurrentGameState = game.currentGameState</span>
<span class="fc" id="L134">        val newBoard = game.currentGameState.board</span>

        //update currentPlayerIndex and check if the next player can make a valid move
//        currentPlayerIndex = (currentPlayerIndex + 1) % newCurrentGameState.playerList.size
<span class="fc" id="L138">        val totalGemsOnBoard = newBoard.gems.values.sum() - newBoard.gems.getValue(GemType.YELLOW)</span>
<span class="fc" id="L139">        val affordableCards = acquirableCards().size</span>
<span class="fc" id="L140">        val reservedCards = newCurrentGameState.currentPlayer.reservedCards.size</span>
<span class="fc" id="L141">        println(totalGemsOnBoard)</span>
<span class="fc" id="L142">        println(affordableCards)</span>
<span class="fc" id="L143">        println(reservedCards)</span>
<span class="pc bpc" id="L144" title="2 of 6 branches missed.">        if((totalGemsOnBoard == 0) &amp;&amp; (affordableCards == 0) &amp;&amp; (reservedCards == 3)){</span>
//            onAllRefreshables { refreshIfNoValidAction() }
<span class="fc" id="L146">            consecutiveNoAction++</span>
<span class="fc" id="L147">            println(&quot;plus one&quot;)</span>
        }

        // if no player can make any move, end game with tie result
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if(consecutiveNoAction == newCurrentGameState.playerList.size){</span>
<span class="nc" id="L152">            newCurrentGameState.playerList = newCurrentGameState.playerList.sortedByDescending { player -&gt; player.score }</span>
//            onAllRefreshables { refreshAfterEndGame(true) }
<span class="nc" id="L154">            return</span>
        }
//        onAllRefreshables { refreshAfterNextPlayer }
<span class="fc" id="L157">    }</span>

//    /**
//     * End game
//     *
//     * @return a list sort by players' score
//     */
//    fun endGame(){
//        val game = rootService.currentGame
//        checkNotNull(game)
//        val currentGameState = game.currentGameState
//
//        currentGameState.playerList = currentGameState.playerList.sortedByDescending { player -&gt; player.score }
//    }

    /**
     * deal a new card to the same place, where a card was removed
     *
     * @param level level of the card
     * @param index  index of the removed card
     */
    fun refill(level: Int,index: Int){
<span class="fc" id="L179">        val game = rootService.currentGame!!</span>
<span class="fc" id="L180">        val board = game.currentGameState.board</span>

<span class="pc bpc" id="L182" title="1 of 4 branches missed.">        when(level){</span>
            1 -&gt; {
<span class="fc" id="L184">                board.levelOneOpen.add(index,board.levelOneCards[0])</span>
<span class="fc" id="L185">                board.levelOneCards.removeAt(0)</span>
            }
            2 -&gt; {
<span class="fc" id="L188">                board.levelTwoOpen.add(index,board.levelTwoCards[0])</span>
<span class="fc" id="L189">                board.levelTwoCards.removeAt(0)</span>
            }
            3 -&gt; {
<span class="fc" id="L192">                board.levelThreeOpen.add(index,board.levelThreeCards[0])</span>
<span class="fc" id="L193">                board.levelThreeCards.removeAt(0)</span>
            }
        }
<span class="fc" id="L196">    }</span>


    /**
     * Check which noble tiles can visit the current player
     * automatic add prestige point to player score if there is only on affordable card
     * @return a mutable list of indexes of the affordable noble tiles on board
     */
    fun checkNobleTiles(): MutableList&lt;Int&gt;{

<span class="fc" id="L206">        val game = rootService.currentGame</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        checkNotNull(game)</span>
<span class="fc" id="L208">        val board = game.currentGameState.board</span>
<span class="fc" id="L209">        val player = game.currentGameState.currentPlayer</span>
<span class="fc" id="L210">        val affordableNobleTile = mutableListOf&lt;Int&gt;()</span>

<span class="fc" id="L212">        board.nobleTiles.forEach { nobleTile -&gt;</span>
            // extract each card out of noble tiles
<span class="fc" id="L214">            val tempGemMap = nobleTile.condition.toMutableMap()</span>
<span class="fc" id="L215">            tempGemMap.forEach { (gemType, _) -&gt;</span>
                // check if the noble can visit the player
<span class="fc" id="L217">                tempGemMap[gemType] = tempGemMap.getValue(gemType) - player.bonus.getValue(gemType)</span>
<span class="fc bfc" id="L218" title="All 6 branches covered.">                if (tempGemMap.filterValues { it &gt;= 0 }.values.sum() == 0) {</span>
<span class="fc" id="L219">                    affordableNobleTile.add(board.nobleTiles.indexOf(nobleTile))</span>
                }
<span class="fc" id="L221">            }</span>
<span class="fc" id="L222">        }</span>

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if(affordableNobleTile.size == 1){</span>
<span class="fc" id="L225">            player.score += board.nobleTiles[affordableNobleTile[0]].prestigePoints</span>
<span class="fc" id="L226">            board.nobleTiles.removeAt(affordableNobleTile[0])</span>
        }

<span class="fc" id="L229">        return affordableNobleTile</span>
    }


    /** checks if the current player has more than ten gems */
    fun checkGems(): Boolean {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        return rootService.currentGame!!.currentGameState.currentPlayer.gems.values.sum() &gt; 10</span>
    }


    /*-----------------------------HELP FUNCTION-----------------------------*/

    /** creates nobleTiles */
    private fun createNobleTiles(playerCount: Int): MutableList&lt;NobleTile&gt; {

<span class="fc" id="L244">        val nobleTileFile = &quot;src/main/resources/splendor-adligenkarten.csv&quot;</span>
<span class="fc" id="L245">        val cardProps: MutableList&lt;String&gt; = File(nobleTileFile).readLines().toMutableList()</span>
<span class="fc" id="L246">        cardProps.removeAt(0)</span>
<span class="fc" id="L247">        val nobleCards = mutableListOf&lt;NobleTile&gt;()</span>

<span class="fc" id="L249">        cardProps.forEach { cardProp -&gt;</span>
<span class="fc" id="L250">            val cardConfig = cardProp.split(&quot;, &quot;)</span>
<span class="fc" id="L251">            val tempMap = mapOf(</span>
<span class="fc" id="L252">                GemType.WHITE to cardConfig[1].trim().toInt(),</span>
<span class="fc" id="L253">                GemType.BLUE to cardConfig[2].trim().toInt(),</span>
<span class="fc" id="L254">                GemType.GREEN to cardConfig[3].trim().toInt(),</span>
<span class="fc" id="L255">                GemType.RED to cardConfig[4].trim().toInt(),</span>
<span class="fc" id="L256">                GemType.BLACK to cardConfig[5].trim().toInt()</span>
            )
<span class="fc" id="L258">            nobleCards.add(</span>
<span class="fc" id="L259">                NobleTile(</span>
<span class="fc" id="L260">                    cardConfig[0].trim().toInt(),</span>
<span class="fc" id="L261">                    tempMap,</span>
<span class="fc" id="L262">                    cardConfig[6].trim().toInt()</span>
                )
            )
<span class="fc" id="L265">        }</span>
<span class="fc" id="L266">        nobleCards.shuffle()</span>
<span class="fc" id="L267">        return  nobleCards.slice(0..playerCount).toMutableList()</span>
    }


    /** creates cardStacks for all devCard levels */
    private fun createCardStack(level: Int): MutableList&lt;DevCard&gt;{

<span class="fc" id="L274">        val cardConfigFile = &quot;src/main/resources/splendor-entwicklungskarten.csv&quot;</span>
<span class="fc" id="L275">        val cardConfigs: MutableList&lt;String&gt; = File(cardConfigFile.trim()).readLines().toMutableList()</span>
<span class="fc" id="L276">        cardConfigs.removeAt(0)</span>
<span class="fc" id="L277">        val cardList = mutableListOf&lt;DevCard&gt;()</span>

<span class="fc bfc" id="L279" title="All 3 branches covered.">        when (level) {</span>
            1 -&gt; {
<span class="fc bfc" id="L281" title="All 2 branches covered.">                for(i in 0..39){</span>
<span class="fc" id="L282">                    val cardConfig = cardConfigs[i].split(&quot;, &quot;)</span>
<span class="fc" id="L283">                    cardList.add(createCard(cardConfig))</span>
                }
            }
            2 -&gt; {
<span class="fc bfc" id="L287" title="All 2 branches covered.">                for(i in 40..69){</span>
<span class="fc" id="L288">                    val cardConfig = cardConfigs[i].split(&quot;, &quot;)</span>
<span class="fc" id="L289">                    cardList.add(createCard(cardConfig))</span>
                }
            }
            else -&gt; {
<span class="fc bfc" id="L293" title="All 2 branches covered.">                for(i in 70..89){</span>
<span class="fc" id="L294">                    val cardConfig = cardConfigs[i].split(&quot;, &quot;)</span>
<span class="fc" id="L295">                    cardList.add(createCard(cardConfig))</span>
                }
            }
        }
<span class="fc" id="L299">        return cardList</span>
    }


    /**
     * Create a development card
     *
     * @param cardProp card properties as String
     * @return a development card object
     */
    fun createCard(cardProp: List&lt;String&gt;): DevCard {

<span class="fc" id="L311">        val tempMap = mapOf(</span>
<span class="fc" id="L312">            GemType.WHITE to cardProp[1].trim().toInt(),</span>
<span class="fc" id="L313">            GemType.BLUE to cardProp[2].trim().toInt(),</span>
<span class="fc" id="L314">            GemType.GREEN to cardProp[3].trim().toInt(),</span>
<span class="fc" id="L315">            GemType.RED to cardProp[4].trim().toInt(),</span>
<span class="fc" id="L316">            GemType.BLACK to cardProp[5].trim().toInt()</span>
        )
<span class="fc bfc" id="L318" title="All 6 branches covered.">        val color = when (cardProp[8].trim()) {</span>
<span class="fc" id="L319">            &quot;diamant&quot; -&gt; GemType.WHITE</span>
<span class="fc" id="L320">            &quot;saphir&quot; -&gt; GemType.BLUE</span>
<span class="fc" id="L321">            &quot;smaragd&quot; -&gt; GemType.GREEN</span>
<span class="fc" id="L322">            &quot;rubin&quot; -&gt; GemType.RED</span>
<span class="fc" id="L323">            &quot;onyx&quot; -&gt; GemType.BLACK</span>
            else -&gt; {
<span class="fc" id="L325">                throw java.lang.IllegalArgumentException(</span>
<span class="fc" id="L326">                    &quot;invalid gem type&quot;</span>
                )
            }
        }
        //create card
<span class="fc" id="L331">        return DevCard(</span>
<span class="fc" id="L332">            cardProp[0].trim().toInt(),</span>
<span class="fc" id="L333">            tempMap,</span>
<span class="fc" id="L334">            cardProp[6].trim().toInt(),</span>
<span class="fc" id="L335">            cardProp[7].trim().toInt(),</span>
<span class="fc" id="L336">            color)</span>
    }

    /**
     * check if the card is for the current player affordable
     *
     * @param card the card which the player chose
     * @param payment map of gems from player
     * @return true if player can this card afford, else return false
     * */
    fun isCardAcquirable(card: DevCard, payment: Map&lt;GemType,Int&gt;): Boolean {

<span class="fc" id="L348">        val tempGemMap = card.price.toMutableMap()</span>

<span class="fc" id="L350">        card.price.forEach { (gemType) -&gt;</span>
<span class="fc" id="L351">            tempGemMap[gemType] = tempGemMap.getValue(gemType) - payment.getValue(gemType)</span>
<span class="fc" id="L352">        }</span>

<span class="fc bfc" id="L354" title="All 4 branches covered.">        val gemsNeeded = tempGemMap.filterValues { it &gt;= 0 }.values.sum()</span>
<span class="fc bfc" id="L355" title="All 4 branches covered.">        return (gemsNeeded == 0) || (gemsNeeded &lt;= payment.getValue(GemType.YELLOW))</span>
    }

    /**
     * check if there are any open card, which player can afford
     *
     * @return a list of Pair( level, cardIndex ) of acquirable card
     */
     fun acquirableCards(): MutableList&lt;Pair&lt;Int,Int&gt;&gt;{

<span class="fc" id="L365">        val game = rootService.currentGame</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        checkNotNull(game)</span>
<span class="fc" id="L367">        val board = game.currentGameState.board</span>
<span class="fc" id="L368">        val playerBonus = game.currentGameState.currentPlayer.bonus</span>
<span class="fc" id="L369">        val playerGems = game.currentGameState.currentPlayer.gems</span>
<span class="fc" id="L370">        val listOfAcquirableCards = mutableListOf&lt;Pair&lt;Int,Int&gt;&gt;()</span>
<span class="fc" id="L371">        val totalOwn : Map&lt;GemType,Int&gt; = mapOf(</span>
<span class="fc" id="L372">            GemType.RED    to (playerBonus.getValue(GemType.RED)   + playerGems.getValue(GemType.RED)),</span>
<span class="fc" id="L373">            GemType.GREEN  to (playerBonus.getValue(GemType.GREEN) + playerGems.getValue(GemType.GREEN)),</span>
<span class="fc" id="L374">            GemType.WHITE  to (playerBonus.getValue(GemType.WHITE) + playerGems.getValue(GemType.WHITE)),</span>
<span class="fc" id="L375">            GemType.BLACK  to (playerBonus.getValue(GemType.BLACK) + playerGems.getValue(GemType.BLACK)),</span>
<span class="fc" id="L376">            GemType.BLUE   to (playerBonus.getValue(GemType.BLUE)  + playerGems.getValue(GemType.BLUE)),</span>
<span class="fc" id="L377">            GemType.YELLOW to   playerGems.getValue(GemType.YELLOW))</span>

<span class="fc bfc" id="L379" title="All 2 branches covered.">        for(i in 0..3) {</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if(isCardAcquirable(board.levelOneOpen[i], totalOwn)){</span>
<span class="fc" id="L381">                listOfAcquirableCards.add(Pair(1,i))</span>
            }
<span class="fc bfc" id="L383" title="All 2 branches covered.">            if(isCardAcquirable(board.levelTwoOpen[i], totalOwn)){</span>
<span class="fc" id="L384">                listOfAcquirableCards.add(Pair(2,i))</span>
            }
<span class="fc bfc" id="L386" title="All 2 branches covered.">            if(isCardAcquirable(board.levelThreeOpen[i], totalOwn)){</span>
<span class="fc" id="L387">                listOfAcquirableCards.add(Pair(3,i))</span>
            }
        }
<span class="fc" id="L390">        return listOfAcquirableCards</span>
    }

//    /**
//     * Check if the current player can perform any valid move in this turn
//     *
//     * @return true if there are at least one valid action. False if there is no valid action.
//     *
//     */
//    fun checkValidAction(): Boolean{
//
//        val game = rootService.currentGame
//        checkNotNull(game)
//        val board = game.currentGameState.board
//        val currentPlayer = game.currentGameState.currentPlayer
//        var totalGemsOnBoard = board.gems.values.sum() - board.gems.getValue(GemType.YELLOW)
//        val affordableCards = acquirableCards().size
//        val reservedCards = currentPlayer.gems.size
//
//        return (totalGemsOnBoard != 0) || (affordableCards != 0) || (reservedCards &lt; 3)
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>